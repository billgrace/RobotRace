<!DOCTYPE html>
<html>
<head>
	<title>Robot Race Track</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style type="text/css">
		body {
			margin: 0px;
			background-color: #fff;
			overflow: hidden;
		}
	</style>
</head>
<body>
	<script type="text/javascript" src="script/three.min.js"></script>
	<script type="text/javascript" src="script/OrbitControls.js"></script>
	<script type="text/javascript" src="script/STLLoader.js"></script>
	<script type="text/javascript" src="script/cannon.min.js"></script>
	<script type="text/javascript" src="script/CannonDebugRenderer.js"></script>
	<script type="text/javascript" src="script/ShowVectors.js"></script>
	<script type="text/javascript" src="script/controls.js"></script>

	<!-- variables shared with scad/stl -->
	<script type="text/javascript">
		var trackInnerRadius;
		var trackWidth;
		var trackThickness;
		var trackStraightStretchLength;
	</script>
	<script type="text/javascript" src="shape/rrTrack.inc"></script>

	<script type="text/javascript">

		var helpDisplayVisible, helpButton, helpTextBox;
		var restartAnimationButtonLoaded;

		var visibleAxes, visibleAxesVisible = true;
		var visibleCameraVector;

		var frameCount = 0, slowMotion = false, outlineBodies = false;

		var camera, renderer, scene, xLight, yLight, zLight;
		var orbitControls;
		var cameraLookingAtVector = new THREE.Vector3(), cameraMoveVector = new THREE.Vector3(), cameraFollowDisplacement = new THREE.Vector3();
		var cameraPositioningMode, cameraTetherLength;

		var world, timeStep = 1/60, caDebugOutliner;

		var horizonGeometry, horizontMaterial, horizonMesh, horizonTexture;
		var horizonMaterialArray = [];

		var groundPlaneMesh, groundPlaneBody, groundPlaneGeometry, groundPlaneShape, groundPlaneMaterial;

		var horizonDistance = 5000;


		var wallHalfHeight = trackWidth;
		var wallHalfThickness = trackThickness;

		var vehicleBody, vehicleMesh;

		init();

		function init() {
			helpButton = new imageButton( "image/QuestionMark.png", "rendererDomElement", 0.01, 0.01, 0.05, 0.05, " ", false, onHelpButtonClick );
			var helpText = "Help Display<br><br>\
			C key: toggle cannon debug outlining<br>\
			H key: toggle help display<br>\
			R key: reset the animation<br>\
			M key: toggle slow motion<br>\
			X key: toggle visible axes<br>\
			<br>\
			F key: camera to 'Follow' mode<br>\
			O key: camera to 'Orbit control' mode<br>\
			T key: camera to 'Track' mode<br>\
			V key: camera to 'aerial View' mode<br>\
			- in Follow and Aerial:<br>\
			--- W/A/S/D keys move camera laterally<br>\
			--- +/- keys move camera in/out<br>\
			";
			helpTextBox = new textBox( helpText, "rendererDomElement", 0.01, 0.01, 0.25, 0.5, "#FFFF00", 1.5, "#000000", 1, "#00FF00" );
			helpTextBox.visible.addEventListener( "mousedown", onHelpTextClick, false );
			helpTextBox.visible.addEventListener( "touchstart", onHelpTextClick, false );
			helpDisplayVisible = undefined;
			// helpButton.activate() is called in animation routine AFTER image has loaded and button is no longer undefined...

			restartAnimationButton = new imageButton( "image/restartAnimationArrow.png", "rendererDomElement", 0.01, 0.06, 0.05, 0.05, " ", false, restartAnimation );
			restartAnimationButtonLoaded = false;

			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 80, 1.3, 1, 20000 );
			camera.position.set( 600, 300, 400 );
			renderer = new THREE.WebGLRenderer();
			renderer.domElement.id = "rendererDomElement";
			document.body.appendChild( renderer.domElement );
			xLight = new THREE.DirectionalLight( 0xffcc88 );
			xLight.position.set( 1, 0, 0 ).normalize();
			scene.add( xLight );
			xMinusLight = new THREE.DirectionalLight( 0xff88cc );
			xMinusLight.position.set( -1, 0, 0 ).normalize();
			scene.add( xMinusLight );
			yLight = new THREE.DirectionalLight( 0xffffff );
			yLight.position.set( 0, 1, 0 ).normalize();
			scene.add( yLight );
			zLight = new THREE.DirectionalLight( 0xcc88ff );
			zLight.position.set( 0, 0, 1 ).normalize();
			scene.add( zLight );
			zMinusLight = new THREE.DirectionalLight( 0x88ccff );
			zMinusLight.position.set( 0, 0, -1 ).normalize();
			scene.add( zMinusLight );

			orbitControls = new THREE.OrbitControls( camera );
			orbitControls.damping = 0.2;
			orbitControls.maxDistance = horizonDistance;
			orbitControls.maxPolarAngle = Math.PI / 2;
			orbitControls.addEventListener( 'change', render );
			setCameraPositioningMode( "Orbit" );

			world = new CANNON.World();
			world.gravity.set( 0, -9.8, 0 );
			world.broadphase = new CANNON.NaiveBroadphase();

			caDebugOutliner = new THREE.CannonDebugRenderer( scene, world );

			// Horizon mesh
			// ... the jpg images are "painted" on the OUTSIDE faces of the box so flip them right-left to view from the inside
			// ... with the camera on the +Y side of 0, 0, 0 (with +X headingn off to the right) looking through 0, 0, 0 it's "seeing" the "south" wall (face 6 in the loading order)
			// ...loading order for box faces is west, east, sky, ground, north, south
			horizonMaterialArray.push( new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'image/westWallMirrored.jpg' ), side:THREE.DoubleSide } ) );
			horizonMaterialArray.push( new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'image/eastWallMirrored.jpg' ), side:THREE.DoubleSide } ) );
			horizonMaterialArray.push( new THREE.MeshBasicMaterial( { color:0x8888ff, side:THREE.DoubleSide } ) );
			horizonMaterialArray.push( new THREE.MeshBasicMaterial( { color:0x201000, side:THREE.DoubleSide } ) );
			horizonMaterialArray.push( new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'image/northWallMirrored.jpg' ), side:THREE.DoubleSide } ) );
			horizonMaterialArray.push( new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'image/southWallMirrored.jpg' ), side:THREE.DoubleSide } ) );
			horizonMaterial = new THREE.MeshFaceMaterial( horizonMaterialArray );
			horizonGeometry = new THREE.BoxGeometry( 2 * horizonDistance, 2 * horizonDistance, 2 * horizonDistance );
			horizonMesh = new THREE.Mesh( horizonGeometry, horizonMaterial );
			horizonMesh.position.set( 0, 0.9 * horizonDistance, 0 );
			scene.add( horizonMesh );

			// Ground plane mesh
			groundPlaneGeometry = new THREE.PlaneBufferGeometry( 2.1 * horizonDistance, 2.1 * horizonDistance );
			groundPlaneMaterial = new THREE.MeshLambertMaterial( { color:0x883311 } );
			groundPlaneMesh = new THREE.Mesh( groundPlaneGeometry, groundPlaneMaterial );
			groundPlaneMesh.rotation.set( - Math.PI / 2, 0, 0 );
			groundPlaneMesh.position.set( 0, -30, 0 );
			scene.add( groundPlaneMesh );

			// Race track mesh
			var stlLoader = new THREE.STLLoader();
			stlLoader.load( "shape/rrTrack.stl", function( trackGeometry ) {
				var trackMaterial = new THREE.MeshPhongMaterial( { color:0xf0c010 } );
				var trackMesh = new THREE.Mesh( trackGeometry, trackMaterial );
				trackMesh.rotation.set( -Math.PI / 2, 0, 0 );
				scene.add( trackMesh );
			} );
			// Race track body
			// - race track body bottom
			var trackBodyMaterial = new CANNON.Material();
			var trackBodyBottomHalfWidth = ( trackStraightStretchLength / 2 ) + trackInnerRadius + trackWidth;
			var trackBottomShape = new CANNON.Box( new CANNON.Vec3( trackBodyBottomHalfWidth, wallHalfThickness, trackInnerRadius + trackWidth ) );
			var trackBottomBody = new CANNON.Body( { material: trackBodyMaterial } );
			trackBottomBody.addShape( trackBottomShape );
			trackBottomBody.position.set( ( trackStraightStretchLength / 2 ), -wallHalfThickness, 0 );
			world.add( trackBottomBody );
			// - race track body top
			var trackTopBody = new CANNON.Body( { material: trackBodyMaterial } );
			trackTopBody.addShape( trackBottomShape );
			trackTopBody.position.set( 500, trackWidth * 2, 0 );
			world.add( trackTopBody );
			// - race track body curve inside walls
			// - - make "n" + 1 vertical wall segments to "surround" the half-circle curve
			// - - angle between each segment is pi/n and rotation of first one is 0 to mate with straight section wall
			var curveWallCount = 32;
			var trackCurveInsideShape = new CANNON.Box( new CANNON.Vec3( ( (trackInnerRadius * Math.tan( Math.PI / ( 2 * curveWallCount ) ) ) ), wallHalfHeight, wallHalfThickness ) );
			var trackCurveInsideRadius = trackInnerRadius - wallHalfThickness;
			for( var i = 0; i <= curveWallCount; i ++ ) {
				// first the curve centered at x = 0
				// var rotation = Math.PI / ( 2 * curveWallCount ) + i * ( Math.PI / curveWallCount );
				var rotation = i * ( Math.PI / curveWallCount );
				var xTranslation = trackCurveInsideRadius * Math.sin( rotation );
				var zTranslation = trackCurveInsideRadius * Math.cos( rotation );
				trackCurveInsideBody1 = new CANNON.Body( { material: trackBodyMaterial } );
				trackCurveInsideBody1.addShape( trackCurveInsideShape );
				trackCurveInsideBody1.position.set( -xTranslation, trackWidth, -zTranslation );
				trackCurveInsideBody1.quaternion.setFromAxisAngle( new CANNON.Vec3( 0, 1, 0 ), rotation );
				world.add( trackCurveInsideBody1 );
				// then the curve at the other end
				trackCurveInsideBody2 = new CANNON.Body( { material: trackBodyMaterial } );
				trackCurveInsideBody2.addShape( trackCurveInsideShape );
				trackCurveInsideBody2.position.set( trackStraightStretchLength + xTranslation, trackWidth, zTranslation );
				trackCurveInsideBody2.quaternion.setFromAxisAngle( new CANNON.Vec3( 0, 1, 0 ), rotation );
				world.add( trackCurveInsideBody2 );
			}
			// - race track body straight inside walls
			var trackStraightInsideShape = new CANNON.Box( new CANNON.Vec3( ( trackStraightStretchLength / 2 ), wallHalfHeight, wallHalfThickness ) );
			var trackStraightInsideBody1 = new CANNON.Body( { material: trackBodyMaterial } );
			trackStraightInsideBody1.addShape( trackStraightInsideShape );
			trackStraightInsideBody1.position.set( ( trackStraightStretchLength / 2 ), trackWidth, ( trackInnerRadius - wallHalfThickness ) );
			world.add( trackStraightInsideBody1 );
			var trackStraightInsideBody2 = new CANNON.Body( { material: trackBodyMaterial } );
			trackStraightInsideBody2.addShape( trackStraightInsideShape );
			trackStraightInsideBody2.position.set( ( trackStraightStretchLength / 2 ), trackWidth, -( trackInnerRadius - wallHalfThickness ) );
			world.add( trackStraightInsideBody2 );
			// - race track body straight outside walls
			var trackStraightOutsideShape = new CANNON.Box( new CANNON.Vec3( ( trackStraightStretchLength / 2 ), wallHalfHeight, wallHalfThickness ) );
			var trackStraightOutsideBody1 = new CANNON.Body( { material: trackBodyMaterial } );
			trackStraightOutsideBody1.addShape( trackStraightOutsideShape );
			trackStraightOutsideBody1.position.set( ( trackStraightStretchLength / 2 ), trackWidth, ( trackInnerRadius + trackWidth + wallHalfThickness ) );
			world.add( trackStraightOutsideBody1 );
			var trackStraightOutsideBody2 = new CANNON.Body( { material: trackBodyMaterial } );
			trackStraightOutsideBody2.addShape( trackStraightOutsideShape );
			trackStraightOutsideBody2.position.set( ( trackStraightStretchLength / 2 ), trackWidth, -( trackInnerRadius + trackWidth + wallHalfThickness ) );
			world.add( trackStraightOutsideBody2 );
			// - race track body curve outside walls
			// - - make "n" + 1 vertical wall segments to "surround" the half-circle curve
			// - - angle between each segment is pi/n and rotation of first one is 0 to mate with straight section wall

			// var trackCurveOutsideShape = new CANNON.Box( new CANNON.Vec3( ( 1.2 * ( (trackInnerRadius + trackWidth ) * Math.tan( Math.PI / ( 2 * curveWallCount ) ) ) ), wallHalfHeight, wallHalfThickness ) );

			var trackCurveOutsideShape = new CANNON.Box( new CANNON.Vec3( ( (trackInnerRadius + trackWidth ) * Math.tan( Math.PI / ( 2 * curveWallCount ) ) ), wallHalfHeight, wallHalfThickness ) );
			var trackCurveOutsideRadius = trackInnerRadius + trackWidth + wallHalfThickness;
			for( var i = 0; i <= curveWallCount; i ++ ) {
				// first the curve centered at x = 0
				// var rotation = Math.PI / ( 2 * curveWallCount ) + i * ( Math.PI / curveWallCount );
				var rotation = i * ( Math.PI / curveWallCount );
				var xTranslation = trackCurveOutsideRadius * Math.sin( rotation );
				var zTranslation = trackCurveOutsideRadius * Math.cos( rotation );
				trackCurveOutsideBody1 = new CANNON.Body( { material: trackBodyMaterial } );
				trackCurveOutsideBody1.addShape( trackCurveOutsideShape );
				trackCurveOutsideBody1.position.set( -xTranslation, trackWidth, -zTranslation );
				trackCurveOutsideBody1.quaternion.setFromAxisAngle( new CANNON.Vec3( 0, 1, 0 ), rotation );
				world.add( trackCurveOutsideBody1 );
				// then the curve at the other end
				trackCurveOutsideBody2 = new CANNON.Body( { material: trackBodyMaterial } );
				trackCurveOutsideBody2.addShape( trackCurveOutsideShape );
				trackCurveOutsideBody2.position.set( trackStraightStretchLength + xTranslation, trackWidth, zTranslation );
				trackCurveOutsideBody2.quaternion.setFromAxisAngle( new CANNON.Vec3( 0, 1, 0 ), rotation );
				world.add( trackCurveOutsideBody2 );
			}

			visibleAxes = new THREE.AxisHelper( 300 );
			visibleAxesVisible = false;
			visibleCameraVector = new VisibleVector( camera.getWorldDirection(), camera.position, 500, 1.0, 0.5, 1.0 );
			scene.add( visibleCameraVector );

			vehicleMesh = new THREE.Mesh( new THREE.SphereGeometry( trackWidth / 3 ), new THREE.MeshLambertMaterial( { color: 0x6789ab } ) );
			scene.add( vehicleMesh );
			var vehicleBodyMaterial = new CANNON.Material();
			vehicleBody = new CANNON.Body( { material: vehicleBodyMaterial, mass: 100 } );
			vehicleBody.addShape( new CANNON.Sphere( trackWidth / 3 ) );
			world.add( vehicleBody );

			var vehicleTrackMaterialContactEquation = new CANNON.ContactMaterial( vehicleBodyMaterial, trackBodyMaterial, { friction: 0, restitution: 0.0 } );
			world.addContactMaterial( vehicleTrackMaterialContactEquation );

			restartAnimation();

			document.addEventListener( "keydown", checkKeyDown );
			window.addEventListener( "resize", onWindowResize, false );
			window.addEventListener( "orientationchange", onWindowResize, false );

			animate();
		}

		function moveMeshToBody() {
			vehicleMesh.position.copy( vehicleBody.position );
		}

		function setCameraPositioningMode( mode ) {
			// disable current camera positioning mode
			switch( cameraPositioningMode ) {
				case "Aerial":
					break;
				case "Follow":
					break;
				case "Orbit":
					orbitControls.enabled = false;
					break;
				case "Track":
					break;
				default:
					break;
			}
			cameraPositioningMode = mode;
			// enable new camera positioning mode
			switch( cameraPositioningMode ) {
				case "Aerial":
					break;
				case "Follow":
					// Initialize the tether length between vehicle and camera to its present value.
					cameraTetherLength = vehicleMesh.position.clone().sub( camera.position ).length();
					// Initialize the manual adjustment vector to "none yet"
					cameraFollowDisplacement.set( 0, 0, 0 );
					break;
				case "Orbit":
					orbitControls.enabled = true;
					break;
				case "Track":
					break;
				default:
					break;
			}
		}

		function moveCameraUp() {
			switch( cameraPositioningMode ) {
				case "Aerial":
					camera.position.y *= 1.1;
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					cameraFollowDisplacement.y += 0.1 * cameraTetherLength;
					break;
				case "Orbit":
					break;
				case "Track":
					camera.position.y *= 1.1;
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraDown() {
			switch( cameraPositioningMode ) {
				case "Aerial":
					camera.position.y *= 0.9;
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					cameraFollowDisplacement.y -= 0.1 * cameraTetherLength;
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Track":
					camera.position.y *= 0.9;
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraLeft() {
			switch( cameraPositioningMode ) {
				case "Aerial":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					camera.position.add( leftDirection.multiplyScalar( 0.1 * camera.position.length() ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					camera.position.add( leftDirection.multiplyScalar( 0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Track":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					camera.position.add( leftDirection.multiplyScalar( 0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraRight() {
			switch( cameraPositioningMode ) {
				case "Aerial":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					camera.position.add( leftDirection.multiplyScalar( -0.1 * camera.position.length() ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					camera.position.add( leftDirection.multiplyScalar( -0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Track":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					camera.position.add( leftDirection.multiplyScalar( -0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraIn() {
			switch( cameraPositioningMode ) {
				case "Aerial":
					camera.position.add( camera.getWorldDirection().multiplyScalar( 0.1 * camera.position.length() ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					camera.position.add( camera.getWorldDirection().multiplyScalar( 0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Track":
					camera.position.add( camera.getWorldDirection().multiplyScalar( 0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraOut() {
			switch( cameraPositioningMode ) {
				case "Aerial":
					camera.position.add( camera.getWorldDirection().multiplyScalar( -0.1 * camera.position.length() ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					camera.position.add( camera.getWorldDirection().multiplyScalar( -0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Track":
					camera.position.add( camera.getWorldDirection().multiplyScalar( -0.1 * camera.position.length() ) );
					camera.lookAt( vehicleMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}

		function toggleHelpDisplay() {
			if( helpDisplayVisible ) {
				helpDisplayVisible = false;
				helpButton.activate();
				helpTextBox.deactivate();
				// helpDisplayElement.style.display = "none";
			} else {
				helpDisplayVisible = true;
				helpButton.deactivate();
				helpTextBox.activate();
				// helpDisplayElement.style.display = "block";
			}
		}
		function onHelpButtonClick( event ) {
			toggleHelpDisplay();
		}
		function onHelpTextClick( event ) {
			if( helpDisplayVisible )
				toggleHelpDisplay();
		}

		function checkKeyDown( event ) {
			if( event.defaultPrevented ) return;
			var handled = false;
			var keyCode = event.keyCode;
			if( keyCode !== undefined ) {
				switch( keyCode ) {
					case 32: // space bar
						break;
					case 37: // left arrow
						break;
					case 39: // right arrow
						break;
					case 40: // down arrow
						break;
					case 38: // up arrow
						break;
					case 109: // minus key on keypad
						moveCameraOut();
						handled = true;
						break;
					case 189: // minus key on main keyboard (if shift-down is false it's the "-" rather than the "_")
						if( !event.shiftKey ) {
							moveCameraOut();
							handled = true;
						}
						break;
					case 187: // plus key on main keyboard (if shift-down is true it's the "+" rather than the "=")
						if( event.shiftKey ) {
							moveCameraIn();
							handled = true;
						}
						break;
					case 107: // plus key on key pad
						moveCameraIn();
						handled = true;
						break;
					case 65: // A
						moveCameraLeft();
						handled = true;
						break;
					case 66: // B
						break;
					case 67: // C
						outlineBodies = !outlineBodies;
						handled = true;
						break;
					case 68: // D
						moveCameraRight();
						handled = true;
						break;
					case 69: // E
						break;
					case 70: // F
						setCameraPositioningMode( "Follow" );
						handled = true;
						break;
					case 71: // G
						break;
					case 72: // H
						toggleHelpDisplay();
						handled = true;
						break;
					case 73: // I
						break;
					case 74: // J
						break;
					case 75: // K
						break;
					case 76: // L
						break;
					case 77: // M
						slowMotion = !slowMotion;
						handled = true;
						break;
					case 78: // N
						break;
					case 79: // O
						setCameraPositioningMode( "Orbit" );
						handled = true;
						break;
					case 80: // P
						break;
					case 81: // Q
						break;
					case 82: // R
						if( !event.metaKey ) {
							restartAnimation();
							handled = true;
						}
						break;
					case 83: // S
						moveCameraDown();
						handled = true;
						break;
					case 84: // T
						setCameraPositioningMode( "Track" );
						handled = true;
						break;
					case 85: // U
						moveCameraUp();
						handled = true;
						break;
					case 86: // V
						setCameraPositioningMode( "Aerial" );
						handled = true;
						break;
					case 87: // W
						moveCameraUp();
						handled = true;
						break;
					case 88: // X
						if( visibleAxesVisible ) {
							visibleAxesVisible = false;
							scene.remove( visibleAxes );
						} else {
							visibleAxesVisible = true;
							scene.add( visibleAxes );
						}
						break;
					case 89: // Y
						break;
					case 90: // Z
						break;
					default:
						break;
				}
			}
			if( handled ) {
				event.preventDefault();
			}
		}

		function onWindowResize() {
			var layout = "portrait";
			if( window.innerWidth > window.innerHeight )
				layout = "landscape";
		}

		function restartAnimation() {
			vehicleBody.velocity = new CANNON.Vec3( 2000, 0, 0 );
			vehicleBody.position.set( 0, 100, trackInnerRadius + ( trackWidth / 2 ) );
		}

		function processPhysics() {
			world.step( timeStep );
			moveMeshToBody();
		}

		function render() {
			renderer.setSize( window.innerWidth, window.innerHeight );
			camera.updateProjectionMatrix();
			visibleCameraVector.update( cameraLookingAtVector );
			renderer.render( scene, camera );
		}

		function animate() {
			requestAnimationFrame( animate );
			if( helpDisplayVisible == undefined) {
				// We get here if we're still waiting for the help button image to load and the button to become defined
				if( helpButton != undefined ) {
					// We get here if our wait is over and the button is ready
					helpDisplayVisible = false;
					helpButton.activate();
				}
			}
			if( restartAnimationButtonLoaded == false ) {
				if( restartAnimationButton != undefined ) {
					restartAnimationButtonLoaded = true;
					restartAnimationButton.activate();
				}
			}
			var timeToAnimate;
			frameCount++;
			if( slowMotion ) {
				timeToAnimate = ( 0 ==  ( frameCount % 25 ) );
			} else {
				timeToAnimate = true;
			}
			if( timeToAnimate ) {
			switch( cameraPositioningMode ) {
				case "Aerial":
					// Camera position is controlled by up/down/left/right/in/out controls.
					// Camera is always looking at ( 0, 0, 0 ).
					break;
				case "Follow":
					// Camera is tethered to the vehicle, being pulled along by it, and looking at the vehicle.
					// Up/down/left/right/in/out adjusts the camera position relative to the vehicle.
					// Get the direction of the vehicle's present velocity
					var vehicleVelocity = new THREE.Vector3();
					vehicleVelocity.copy( vehicleBody.velocity );
					var velocityDirection = new THREE.Vector3();
					velocityDirection.copy( vehicleVelocity.clone().normalize() );
					// Make a vector with the original tether length and a direction opposite that of the present vehicle velocity
					var cameraTetherPoint = new THREE.Vector3();
					cameraTetherPoint.copy( velocityDirection.clone().multiplyScalar( -cameraTetherLength ) );
					// Add the accumulated manual control camera adjustments to this vector
					var cameraMoveVector = new THREE.Vector3();
					cameraMoveVector.addVectors( cameraTetherPoint, cameraFollowDisplacement );
					// Add the vehicle's position this displacement vector to get the camera's new position in world coordinates 
					var newCameraPosition = new THREE.Vector3();
					newCameraPosition.addVectors( vehicleMesh.position, cameraMoveVector );
					// Update the camera position and "lookAt" parameter
					camera.position.copy( newCameraPosition );
					camera.lookAt( vehicleMesh.position );
					break;
				case "Orbit":
					// Camera position is controlled by the THREE.js OrbitControls function.
					orbitControls.update();
					break;
				case "Track":
					// Camera position is controlled by up/down/left/right/in/out controls.
					// Camera is always looking at the vehicle.
					camera.lookAt( vehicleMesh.position );
					break;
				default:
					break;
			}
				processPhysics();
				if( outlineBodies )
					caDebugOutliner.update();
				else
					caDebugOutliner.depopulate();
				render();
			}
		}
	</script>
</body>
</html>
