<!DOCTYPE html>
<html>
<head>
	<title>Robot Race Track</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style type="text/css">
		body {
			margin: 0px;
			background-color: #fff;
			overflow: hidden;
		}
	</style>
</head>
<body>
	<script type="text/javascript" src="script/three.min.js"></script>
	<script type="text/javascript" src="script/OrbitControls.js"></script>
	<script type="text/javascript" src="script/stats.min.js"></script>
	<script type="text/javascript" src="script/cannon.min.js"></script>
	<script type="text/javascript" src="script/CannonDebugRenderer.js"></script>
	<script type="text/javascript" src="script/showVectors.js"></script>
	<script type="text/javascript" src="script/controls.js"></script>
	<script type="text/javascript" src="script/rrTrack.js"></script>
	<script type="text/javascript" src="script/rrHorizon.js"></script>
	<script type="text/javascript">

		var trackPathPoints = [], currentTrackPathPoint;
		var currentTrackPathPointBody;
		var trackPathCurrentPoint = new THREE.Vector3(), trackPathNextPoint = new THREE.Vector3();
		var trackPathCurrentDirection = new THREE.Vector3(), trackPathNextDirection = new THREE.Vector3();
		var trackPathCurrentDisplacement = new THREE.Vector3();
		var trackPathPointsPerSection = 20;
		var trackPathPointVisibleRadius = 3.0;
		var trackPathPointPhysicalRadius = 0.01;
		var trackPathPointsAreVisible;

		var animationPaused;

		var panelBarWidth = 290, panelBarHeight = 45, panelBarHorizontalMargin = 5, panelBarVerticalMargin = 5;
		var panelCloseButtonWidth = ( ( panelBarWidth / 3 ) | 0 ), panelCloseButtonHeight = ( ( panelBarHeight / 3 ) | 0 );
		var panelWidth = ( ( panelBarWidth + ( 2 * panelBarHorizontalMargin ) ) | 0 );
		var panelHorizontalMargin = 5, panelVerticalMargin = 5;
		var panelOpacity = 0.3, panelBackgroundColor = "#222";
		var panelBorderStyle = "solid", panelBorderWidth = 3, panelBorderColor = "#C00", panelBorderRadius = "15px";
		var panelTitleOpacity = 0.9, panelTitleBackgroundColor = "#440", panelTitleTextColor = "#FF0";
		var panelTitlePresentColor = "LightYellow";
		var panelTitleBorderStyle = "solid", panelTitleBorderWidth = 3, panelTitleBorderColor = "#0CC", panelTitleBorderRadius = "10px";
		var panelTitleFontSize = "23px";
		var panelSelectOpacity = 0.9, panelSelectBackgroundColor = "#448", panelSelectTextColor = "#0CC";
		var panelSelectChoiceColor = "Orange";
		var panelSelectBorderStyle = "solid", panelSelectBorderWidth = 3, panelSelectBorderColor = "#8CC", panelSelectBorderRadius = "10px";
		var panelSelectFontSize = "15px";
		var numberOfPointOfViewPanelEntries = 5;
		var pointOfViewPanelHeight = ( ( ( ( numberOfPointOfViewPanelEntries + 1 ) * ( panelBarHeight + panelBarVerticalMargin ) ) + ( panelCloseButtonHeight + panelBarVerticalMargin ) + panelBarVerticalMargin ) | 0 );
		var pointOfViewPanelDiv, pointOfViewButton, pointOfViewButtonLoaded;
		var pointOfViewTitleDiv;
		var pointOfViewSelectArialDiv;
		var pointOfViewSelectFollowDiv;
		var pointOfViewSelectOrbitDiv;
		var pointOfViewSelectRobotDiv;
		var pointOfViewSelectTrackDiv;
		var pointOfViewClosePanelButton;
		var pointOfViewPanelIsOpen = false;

		var numberOfShovelPanelEntries = 3;
		var shovelPanelHeight = ( ( ( ( numberOfShovelPanelEntries + 1 ) * ( panelBarHeight + panelBarVerticalMargin ) ) + ( panelCloseButtonHeight + panelBarVerticalMargin ) + panelBarVerticalMargin ) | 0 );
		var shovelPanelDiv, shovelButton, shovelButtonLoaded;
		var shovelToggleCannonDiv;
		var shovelToggleAxesDiv;
		var shovelCloseButtonDiv;
		var shovelPanelIsOpen = false;

		var restartAnimationButton, restartAnimationButtonLoaded;

		var upDownLeftRightButton, upDownLeftRightButtonLoaded;
		var upDownLeftRightButtonMaxLeftRightChange = 0.5, upDownLeftRightButtonMaxUpDownChange = 0.5;
		var inOutButtonMaxInOutChange = 0.5;

		var inOutButton, inOutButtonLoaded;

		var chooseTrack0Button, chooseTrack1Button, chooseTrack2Button, chooseTrack3Button;
		var chooseTrackButtonsActivated;

		var visibleAxes, visibleAxesVisible;
		var cannonAxes, cannonAxesVisible;
		var visibleCameraVector;

		var frameCount = 0, slowMotion = false, outlineBodies = false;

		var camera, renderer, scene, xLight, yLight, zLight;
		var orbitControls;
		var cameraLookingAtVector = new THREE.Vector3(), cameraMoveVector = new THREE.Vector3();
		var cameraFollowDisplacement = new THREE.Vector3(), cameraRobotDisplacement = new THREE.Vector3();
		var cameraPositioningMode, cameraTetherLength, cameraForwardViewDistance;

		var world, timeStep = 1/60, caDebugOutliner;

		var groundPlaneMesh, groundPlaneBody, groundPlaneGeometry, groundPlaneShape, groundPlaneMaterial;

		var robotBody, robotMesh;

		var stats;

		init();

		function makeTrackPathPoint( pointLocation ) {
			var newPointLocation = new THREE.Vector3();
			newPointLocation.copy( pointLocation );
			var newVisiblePointMesh = new THREE.Mesh( new THREE.SphereGeometry( rrTrackLayout[ 0 ].visibleTrackPathPointRadius ), new THREE.MeshLambertMaterial( { color: 0xff0000 } ) );
			newVisiblePointMesh.position.copy( pointLocation );
			scene.add( newVisiblePointMesh );
			var newTrackPathPoint = {
				location: newPointLocation,
				visible: true,
				mesh: newVisiblePointMesh
			}
			trackPathPoints.push( newTrackPathPoint );
		}
		function turnOnAllVisiblePoints() {
			for( var i = 0; i < trackPathPoints.length; i++ ) {
				if( !trackPathPoints[ i ].visible ) {
					trackPathPoints[ i ].visible = true;
					scene.add( trackPathPoints[ i ].mesh );
				}
			}
			trackPathPointsAreVisible = true;
		}
		function turnOffAllVisiblePoints() {
			for( var i = 0; i < trackPathPoints.length; i++ ) {
				if( trackPathPoints[ i ].visible ) {
					trackPathPoints[ i ].visible = false;
					scene.remove( trackPathPoints[ i ].mesh );
				}
			}
			trackPathPointsAreVisible = false;
		}
		function turnOnVisibleTrackPathPoint( index ) {
			if( !trackPathPoints[ index ].visible ) {
				trackPathPoints[ index ].visible = true;
				scene.add( trackPathPoints[ index ].mesh );
			}
		}
		function turnOffVisibleTrackPathPoint( index ) {
			if( trackPathPoints[ index ].visible ) {
				trackPathPoints[ index ].visible = false;
				scene.remove( trackPathPoints[ index ].mesh );
			}
		}
		function makeTrackPointsFromTrackPieces() {
			// Empty the array
			trackPathPoints.length = 0;
			// for( var currentPieceIndex = 0; currentPieceIndex < rrTrackPieces.length; currentPieceIndex++ ) {
			for( var currentPieceIndex = 0; currentPieceIndex < rrTrackPieces.length; currentPieceIndex++ ) {
				makeTrackPathPoint( rrTrackPieces[ currentPieceIndex ].piecePathStartPoint );
			}
		}

		function init() {

			scene = new THREE.Scene();

			world = new CANNON.World();
			world.gravity.set( 0, -9.8, 0 );
			world.broadphase = new CANNON.NaiveBroadphase();

			pointOfViewPanelDiv = document.createElement( "div" );
			pointOfViewPanelDiv.style.cssText = "position:absolute;display:none";
			pointOfViewPanelDiv.style.left = "0" + ( panelHorizontalMargin | 0 ) + "px";
			pointOfViewPanelDiv.style.top = "0" + ( panelVerticalMargin | 0 ) + "px";
			pointOfViewPanelDiv.style.width = "0" + ( panelWidth | 0 ) + "px";
			pointOfViewPanelDiv.style.height = "0" + ( pointOfViewPanelHeight | 0 ) + "px";
			pointOfViewPanelDiv.style.backgroundColor = panelBackgroundColor;
			pointOfViewPanelDiv.style.opacity = panelOpacity;
			pointOfViewPanelDiv.style.borderStyle = panelBorderStyle;
			pointOfViewPanelDiv.style.borderWidth = "0" + ( panelBorderWidth | 0 ) + "px";
			pointOfViewPanelDiv.style.borderColor = panelBorderColor;
			pointOfViewPanelDiv.style.borderRadius = panelBorderRadius;
			document.body.appendChild( pointOfViewPanelDiv );

			pointOfViewTitleDiv = document.createElement( "div" );
			pointOfViewTitleDiv.style.cssText = "position:absolute;text-align:center;display:none";
			pointOfViewTitleDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			pointOfViewTitleDiv.style.top = "0" + ( ( panelVerticalMargin + ( 0 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewTitleDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			pointOfViewTitleDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewTitleDiv.style.lineHeight = pointOfViewTitleDiv.style.height;
			pointOfViewTitleDiv.style.color = panelTitleTextColor;
			pointOfViewTitleDiv.style.fontSize = panelTitleFontSize;
			pointOfViewTitleDiv.style.backgroundColor = panelTitleBackgroundColor;
			pointOfViewTitleDiv.style.opacity = panelTitleOpacity;
			pointOfViewTitleDiv.style.borderStyle = panelTitleBorderStyle;
			pointOfViewTitleDiv.style.borderWidth = "0" + ( panelTitleBorderWidth | 0 ) + "px";
			pointOfViewTitleDiv.style.borderColor = panelTitleBorderColor;
			pointOfViewTitleDiv.style.borderRadius = panelTitleBorderRadius;
			document.body.appendChild( pointOfViewTitleDiv );

			pointOfViewSelectArrowsDiv = document.createElement( "div" );
			pointOfViewSelectArrowsDiv.style.cssText = "position:absolute;text-align:center;display:none";
			pointOfViewSelectArrowsDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			pointOfViewSelectArrowsDiv.style.top = "0" + ( ( panelVerticalMargin + ( 1 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectArrowsDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			pointOfViewSelectArrowsDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectArrowsDiv.style.color = panelSelectTextColor;
			pointOfViewSelectArrowsDiv.style.fontSize = panelSelectFontSize;
			pointOfViewSelectArrowsDiv.style.backgroundColor = panelSelectBackgroundColor;
			pointOfViewSelectArrowsDiv.style.opacity = panelSelectOpacity;
			pointOfViewSelectArrowsDiv.style.borderStyle = panelSelectBorderStyle;
			pointOfViewSelectArrowsDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			pointOfViewSelectArrowsDiv.style.borderColor = panelSelectBorderColor;
			pointOfViewSelectArrowsDiv.style.borderRadius = panelSelectBorderRadius;
			pointOfViewSelectArrowsDiv.innerHTML = "This button chooses <span style='color:" + panelSelectChoiceColor + "'>Arrows</span><br>\
				for a view you can move with the arrows";
			pointOfViewSelectArrowsDiv.addEventListener( "click", onPointOfViewSelectArrowsClick );
			document.body.appendChild( pointOfViewSelectArrowsDiv );

			pointOfViewSelectFollowDiv = document.createElement( "div" );
			pointOfViewSelectFollowDiv.style.cssText = "position:absolute;text-align:center;display:none";
			pointOfViewSelectFollowDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			pointOfViewSelectFollowDiv.style.top = "0" + ( ( panelVerticalMargin + ( 2 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectFollowDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			pointOfViewSelectFollowDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectFollowDiv.style.color = panelSelectTextColor;
			pointOfViewSelectFollowDiv.style.fontSize = panelSelectFontSize;
			pointOfViewSelectFollowDiv.style.backgroundColor = panelSelectBackgroundColor;
			pointOfViewSelectFollowDiv.style.opacity = panelSelectOpacity;
			pointOfViewSelectFollowDiv.style.borderStyle = panelSelectBorderStyle;
			pointOfViewSelectFollowDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			pointOfViewSelectFollowDiv.style.borderColor = panelSelectBorderColor;
			pointOfViewSelectFollowDiv.style.borderRadius = panelSelectBorderRadius;
			pointOfViewSelectFollowDiv.innerHTML = "This button chooses <span style='color:" + panelSelectChoiceColor + "'>Follow</span><br>\
				for a view from behind the robot";
			pointOfViewSelectFollowDiv.addEventListener( "click", onPointOfViewSelectFollowClick );
			document.body.appendChild( pointOfViewSelectFollowDiv );

			pointOfViewSelectOrbitDiv = document.createElement( "div" );
			pointOfViewSelectOrbitDiv.style.cssText = "position:absolute;text-align:center;display:none";
			pointOfViewSelectOrbitDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			pointOfViewSelectOrbitDiv.style.top = "0" + ( ( panelVerticalMargin + ( 3 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectOrbitDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			pointOfViewSelectOrbitDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectOrbitDiv.style.color = panelSelectTextColor;
			pointOfViewSelectOrbitDiv.style.fontSize = panelSelectFontSize;
			pointOfViewSelectOrbitDiv.style.backgroundColor = panelSelectBackgroundColor;
			pointOfViewSelectOrbitDiv.style.opacity = panelSelectOpacity;
			pointOfViewSelectOrbitDiv.style.borderStyle = panelSelectBorderStyle;
			pointOfViewSelectOrbitDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			pointOfViewSelectOrbitDiv.style.borderColor = panelSelectBorderColor;
			pointOfViewSelectOrbitDiv.style.borderRadius = panelSelectBorderRadius;
			pointOfViewSelectOrbitDiv.innerHTML = "This button chooses <span style='color:" + panelSelectChoiceColor + "'>Orbit</span><br>\
				for a view where you drag the world around";
			pointOfViewSelectOrbitDiv.addEventListener( "click", onPointOfViewSelectOrbitClick );
			document.body.appendChild( pointOfViewSelectOrbitDiv );

			pointOfViewSelectRobotDiv = document.createElement( "div" );
			pointOfViewSelectRobotDiv.style.cssText = "position:absolute;text-align:center;display:none";
			pointOfViewSelectRobotDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			pointOfViewSelectRobotDiv.style.top = "0" + ( ( panelVerticalMargin + ( 4 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectRobotDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			pointOfViewSelectRobotDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectRobotDiv.style.color = panelSelectTextColor;
			pointOfViewSelectRobotDiv.style.fontSize = panelSelectFontSize;
			pointOfViewSelectRobotDiv.style.backgroundColor = panelSelectBackgroundColor;
			pointOfViewSelectRobotDiv.style.opacity = panelSelectOpacity;
			pointOfViewSelectRobotDiv.style.borderStyle = panelSelectBorderStyle;
			pointOfViewSelectRobotDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			pointOfViewSelectRobotDiv.style.borderColor = panelSelectBorderColor;
			pointOfViewSelectRobotDiv.style.borderRadius = panelSelectBorderRadius;
			pointOfViewSelectRobotDiv.innerHTML = "This button chooses <span style='color:" + panelSelectChoiceColor + "'>Robot</span><br>\
				for a view from inside the robot";
			pointOfViewSelectRobotDiv.addEventListener( "click", onPointOfViewSelectRobotClick );
			document.body.appendChild( pointOfViewSelectRobotDiv );

			pointOfViewSelectTrackDiv = document.createElement( "div" );
			pointOfViewSelectTrackDiv.style.cssText = "position:absolute;text-align:center;display:none";
			pointOfViewSelectTrackDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			pointOfViewSelectTrackDiv.style.top = "0" + ( ( panelVerticalMargin + ( 5 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectTrackDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			pointOfViewSelectTrackDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewSelectTrackDiv.style.color = panelSelectTextColor;
			pointOfViewSelectTrackDiv.style.fontSize = panelSelectFontSize;
			pointOfViewSelectTrackDiv.style.backgroundColor = panelSelectBackgroundColor;
			pointOfViewSelectTrackDiv.style.opacity = panelSelectOpacity;
			pointOfViewSelectTrackDiv.style.borderStyle = panelSelectBorderStyle;
			pointOfViewSelectTrackDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			pointOfViewSelectTrackDiv.style.borderColor = panelSelectBorderColor;
			pointOfViewSelectTrackDiv.style.borderRadius = panelSelectBorderRadius;
			pointOfViewSelectTrackDiv.innerHTML = "This button chooses <span style='color:" + panelSelectChoiceColor + "'>Track</span><br>\
				for a view that follows the robot";
			pointOfViewSelectTrackDiv.addEventListener( "click", onPointOfViewSelectTrackClick );
			document.body.appendChild( pointOfViewSelectTrackDiv );

			pointOfViewClosePanelButton = document.createElement( "div" );
			pointOfViewClosePanelButton.style.cssText = "position:absolute;text-align:center;display:none";
			pointOfViewClosePanelButton.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin + ( 2 * panelBarWidth / 3 ) ) | 0 ) + "px";
			pointOfViewClosePanelButton.style.top = "0" + ( ( panelVerticalMargin + ( 6 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			pointOfViewClosePanelButton.style.width = "0" + panelCloseButtonWidth + "px";
			pointOfViewClosePanelButton.style.height = "0" + panelCloseButtonHeight + "px";
			pointOfViewClosePanelButton.style.color = panelSelectTextColor;
			pointOfViewClosePanelButton.style.fontSize = panelSelectFontSize;
			pointOfViewClosePanelButton.style.backgroundColor = panelSelectBackgroundColor;
			pointOfViewClosePanelButton.style.opacity = panelSelectOpacity;
			pointOfViewClosePanelButton.style.borderStyle = panelSelectBorderStyle;
			pointOfViewClosePanelButton.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			pointOfViewClosePanelButton.style.borderColor = panelSelectBorderColor;
			pointOfViewClosePanelButton.style.borderRadius = panelSelectBorderRadius;
			pointOfViewClosePanelButton.innerHTML = "Close";
			pointOfViewClosePanelButton.addEventListener( "click", onPointOfViewClosePanelClick );
			document.body.appendChild( pointOfViewClosePanelButton );

			pointOfViewButton = new imageButton( "image/pointOfViewButton.png", 0.01, 0.01, 0.05, 0.05, " ", false, onPointOfViewButtonClick );
			pointOfViewButtonLoaded = false;

			shovelPanelDiv = document.createElement( "div" );
			shovelPanelDiv.style.cssText = "position:absolute;display:none";
			shovelPanelDiv.style.left = "0" + ( panelHorizontalMargin | 0 ) + "px";
			shovelPanelDiv.style.top = "0" + ( panelVerticalMargin | 0 ) + "px";
			shovelPanelDiv.style.width = "0" + ( panelWidth | 0 ) + "px";
			shovelPanelDiv.style.height = "0" + ( shovelPanelHeight | 0 ) + "px";
			shovelPanelDiv.style.backgroundColor = panelBackgroundColor;
			shovelPanelDiv.style.opacity = panelOpacity;
			shovelPanelDiv.style.borderStyle = panelBorderStyle;
			shovelPanelDiv.style.borderWidth = "0" + ( panelBorderWidth | 0 ) + "px";
			shovelPanelDiv.style.borderColor = panelBorderColor;
			shovelPanelDiv.style.borderRadius = panelBorderRadius;
			document.body.appendChild( shovelPanelDiv );

			shovelToggleAxesDiv = document.createElement( "div" );
			shovelToggleAxesDiv.style.cssText = "position:absolute;text-align:center;display:none";
			shovelToggleAxesDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			shovelToggleAxesDiv.style.top = "0" + ( ( panelVerticalMargin + ( 0 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			shovelToggleAxesDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			shovelToggleAxesDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			shovelToggleAxesDiv.style.color = panelSelectTextColor;
			shovelToggleAxesDiv.style.fontSize = panelSelectFontSize;
			shovelToggleAxesDiv.style.backgroundColor = panelSelectBackgroundColor;
			shovelToggleAxesDiv.style.opacity = panelSelectOpacity;
			shovelToggleAxesDiv.style.borderStyle = panelSelectBorderStyle;
			shovelToggleAxesDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			shovelToggleAxesDiv.style.borderColor = panelSelectBorderColor;
			shovelToggleAxesDiv.style.borderRadius = panelSelectBorderRadius;
			shovelToggleAxesDiv.innerHTML = "Toggle display of axes";
			shovelToggleAxesDiv.addEventListener( "click", onShovelToggleAxesClick );
			document.body.appendChild( shovelToggleAxesDiv );

			shovelToggleCannonDiv = document.createElement( "div" );
			shovelToggleCannonDiv.style.cssText = "position:absolute;text-align:center;display:none";
			shovelToggleCannonDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			shovelToggleCannonDiv.style.top = "0" + ( ( panelVerticalMargin + ( 1 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			shovelToggleCannonDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			shovelToggleCannonDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			shovelToggleCannonDiv.style.color = panelSelectTextColor;
			shovelToggleCannonDiv.style.fontSize = panelSelectFontSize;
			shovelToggleCannonDiv.style.backgroundColor = panelSelectBackgroundColor;
			shovelToggleCannonDiv.style.opacity = panelSelectOpacity;
			shovelToggleCannonDiv.style.borderStyle = panelSelectBorderStyle;
			shovelToggleCannonDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			shovelToggleCannonDiv.style.borderColor = panelSelectBorderColor;
			shovelToggleCannonDiv.style.borderRadius = panelSelectBorderRadius;
			shovelToggleCannonDiv.innerHTML = "Toggle outlines on physics bodies";
			shovelToggleCannonDiv.addEventListener( "click", onShovelToggleCannonClick );
			document.body.appendChild( shovelToggleCannonDiv );

			shovelToggleVisibleTrackPathPointsDiv = document.createElement( "div" );
			shovelToggleVisibleTrackPathPointsDiv.style.cssText = "position:absolute;text-align:center;display:none";
			shovelToggleVisibleTrackPathPointsDiv.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin ) | 0 ) + "px";
			shovelToggleVisibleTrackPathPointsDiv.style.top = "0" + ( ( panelVerticalMargin + ( 2 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			shovelToggleVisibleTrackPathPointsDiv.style.width = "0" + ( ( panelWidth - ( 2 * panelBarHorizontalMargin ) ) | 0 ) + "px";
			shovelToggleVisibleTrackPathPointsDiv.style.height = "0" + ( ( panelBarHeight - panelBarVerticalMargin ) | 0 ) + "px";
			shovelToggleVisibleTrackPathPointsDiv.style.color = panelSelectTextColor;
			shovelToggleVisibleTrackPathPointsDiv.style.fontSize = panelSelectFontSize;
			shovelToggleVisibleTrackPathPointsDiv.style.backgroundColor = panelSelectBackgroundColor;
			shovelToggleVisibleTrackPathPointsDiv.style.opacity = panelSelectOpacity;
			shovelToggleVisibleTrackPathPointsDiv.style.borderStyle = panelSelectBorderStyle;
			shovelToggleVisibleTrackPathPointsDiv.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			shovelToggleVisibleTrackPathPointsDiv.style.borderColor = panelSelectBorderColor;
			shovelToggleVisibleTrackPathPointsDiv.style.borderRadius = panelSelectBorderRadius;
			shovelToggleVisibleTrackPathPointsDiv.innerHTML = "Toggle track path point visibility";
			shovelToggleVisibleTrackPathPointsDiv.addEventListener( "click", onShovelToggleVisibleTrackPathPointsClick );
			document.body.appendChild( shovelToggleVisibleTrackPathPointsDiv );

			shovelClosePanelButton = document.createElement( "div" );
			shovelClosePanelButton.style.cssText = "position:absolute;text-align:center;display:none";
			shovelClosePanelButton.style.left = "0" + ( ( panelHorizontalMargin + panelBarHorizontalMargin + ( 2 * panelBarWidth / 3 ) ) | 0 ) + "px";
			shovelClosePanelButton.style.top = "0" + ( ( panelVerticalMargin + ( 3 * ( panelBarHeight + panelBarVerticalMargin ) ) + panelBarVerticalMargin ) | 0 ) + "px";
			shovelClosePanelButton.style.width = "0" + panelCloseButtonWidth + "px";
			shovelClosePanelButton.style.height = "0" + panelCloseButtonHeight + "px";
			shovelClosePanelButton.style.color = panelSelectTextColor;
			shovelClosePanelButton.style.fontSize = panelSelectFontSize;
			shovelClosePanelButton.style.backgroundColor = panelSelectBackgroundColor;
			shovelClosePanelButton.style.opacity = panelSelectOpacity;
			shovelClosePanelButton.style.borderStyle = panelSelectBorderStyle;
			shovelClosePanelButton.style.borderWidth = "0" + ( panelSelectBorderWidth | 0 ) + "px";
			shovelClosePanelButton.style.borderColor = panelSelectBorderColor;
			shovelClosePanelButton.style.borderRadius = panelSelectBorderRadius;
			shovelClosePanelButton.innerHTML = "Close";
			shovelClosePanelButton.addEventListener( "click", onShovelClosePanelClick );
			document.body.appendChild( shovelClosePanelButton );

			shovelButton = new imageButton( "image/shovelButton.png", 0.51, 0.01, 0.05, 0.05, " ", false, onShovelButtonClick );
			shovelButtonLoaded = false;

			restartAnimationButton = new imageButton( "image/restartAnimationArrow.png", 0.94, 0.01, 0.05, 0.05, " ", false, restartAnimation );
			restartAnimationButtonLoaded = false;

			upDownLeftRightButton = new imageButton( "image/upDownLeftRightArrows.png", 0.01, 0.85, 0.1, 0.14, " ", true, upDownLeftRightButtonHandler );
			upDownLeftRightButtonLoaded = false;

			inOutButton = new imageButton( "image/inOutArrows.png", 0.2, 0.85, 0.1, 0.14, " ", true, inOutButtonHandler );
			inOutButtonLoaded = false;

			getTrackLayouts();
			selectTrackLayout( 3 );

			camera = new THREE.PerspectiveCamera( 80, 1.3, 1, rrTrackLayout[ 0 ].horizonDistance * 10 );
			camera.position.copy( rrTrackLayout[ 1 ].location );
			camera.position.z += 200;
			renderer = new THREE.WebGLRenderer();
			renderer.domElement.id = "rendererDomElement";
			document.body.appendChild( renderer.domElement );
			xLight = new THREE.DirectionalLight( 0xffffff );
			xLight.position.set( 1, 0, 0 ).normalize();
			scene.add( xLight );
			xMinusLight = new THREE.DirectionalLight( 0xffffff );
			xMinusLight.position.set( -1, 0, 0 ).normalize();
			scene.add( xMinusLight );
			yLight = new THREE.DirectionalLight( 0xffffff );
			yLight.position.set( 0, 1, 0 ).normalize();
			scene.add( yLight );
			yMinusLight = new THREE.DirectionalLight( 0xffffff );
			yMinusLight.position.set( 0, -1, 0 ).normalize();
			scene.add( yMinusLight );
			zLight = new THREE.DirectionalLight( 0xffffff );
			zLight.position.set( 0, 0, 1 ).normalize();
			scene.add( zLight );
			zMinusLight = new THREE.DirectionalLight( 0xffffff );
			zMinusLight.position.set( 0, 0, -1 ).normalize();
			scene.add( zMinusLight );
			// var ambientLight = new THREE.AmbientLight( 0x555555 );
			// scene.add( ambientLight );

			chooseTrack0Button = new textBox( "Choose<br>Track 1", .5, 0.94, 0.07, 0.04, "red", "1.5", "yellow", "2px", "blue" );
			chooseTrack0Button.visible.addEventListener( "mousedown", onCchooseTrack0ButtonClick, false );
			chooseTrack0Button.visible.addEventListener( "touchstart", onCchooseTrack0ButtonClick, false );
			chooseTrack1Button = new textBox( "Choose<br>Track 2", .6, 0.94, 0.07, 0.04, "red", "1.5", "yellow", "2px", "blue" );
			chooseTrack1Button.visible.addEventListener( "mousedown", onCchooseTrack1ButtonClick, false );
			chooseTrack1Button.visible.addEventListener( "touchstart", onCchooseTrack1ButtonClick, false );
			chooseTrack2Button = new textBox( "Choose<br>Track 3", .7, 0.94, 0.07, 0.04, "red", "1.5", "yellow", "2px", "blue" );
			chooseTrack2Button.visible.addEventListener( "mousedown", onCchooseTrack2ButtonClick, false );
			chooseTrack2Button.visible.addEventListener( "touchstart", onCchooseTrack2ButtonClick, false );
			chooseTrack3Button = new textBox( "Choose<br>Track 4", .8, 0.94, 0.07, 0.04, "red", "1.5", "yellow", "2px", "blue" );
			chooseTrack3Button.visible.addEventListener( "mousedown", onCchooseTrack3ButtonClick, false );
			chooseTrack3Button.visible.addEventListener( "touchstart", onCchooseTrack3ButtonClick, false );
			chooseTrackButtonsActivated = false;

			// currentTrackPathPointBody = new CANNON.Body( { material: new CANNON.Material(), mass: 0 } );
			currentTrackPathPointBody = new CANNON.Body( { material: new CANNON.Material(), mass: 0 } );
			currentTrackPathPointBody.addShape( new CANNON.Sphere( trackPathPointPhysicalRadius ) );
			world.addBody( currentTrackPathPointBody );
			// Make the array of point-locating-vectors that define the physics path along the track
			makeTrackPointsFromTrackPieces();
			turnOffAllVisiblePoints();
			currentTrackPathPoint = 0;

			caDebugOutliner = new THREE.CannonDebugRenderer( scene, world );

			orbitControls = new THREE.OrbitControls( camera );
			orbitControls.damping = 0.2;
			orbitControls.maxDistance = ( horizonDistance * 3 );
			orbitControls.addEventListener( 'change', render );

			visibleAxes = new THREE.AxisHelper( 300 );
			visibleAxesVisible = false;
			cannonAxes = new CannonAxes( 400 );
			cannonAxesVisible = false;
			visibleCameraVector = new VisibleVector( camera.getWorldDirection(), camera.position, 500, 1.0, 0.5, 1.0 );
			scene.add( visibleCameraVector );

			robotMesh = new THREE.Mesh( new THREE.SphereGeometry( rrTrackLayout[ 0 ].trackWidth / 3 ), new THREE.MeshLambertMaterial( { color: 0x6789ab } ) );
			scene.add( robotMesh );
			var robotBodyMaterial = new CANNON.Material();
			robotBody = new CANNON.Body( { material: robotBodyMaterial, mass: 100, linearDamping: 0.9, angularDamping: 0 } );
			robotBody.addShape( new CANNON.Sphere( rrTrackLayout[ 0 ].trackWidth / 3 ) );
			world.addBody( robotBody );

			var mainSpring = new CANNON.Spring( currentTrackPathPointBody, robotBody, {
				localAnchorA: new CANNON.Vec3( 0, 0, 0 ),
				localAnchorB: new CANNON.Vec3( 0, 0, 0 ),
				restLength: 0,
				stiffness: 2000,
				damping: 1
			} );
			world.addEventListener( "postStep", function( event ) {
				mainSpring.applyForce();
			} );
			var robotTrackMaterialContactEquation = new CANNON.ContactMaterial( robotBodyMaterial, trackBodyMaterial, { friction: 0, restitution: 0.0 } );
			world.addContactMaterial( robotTrackMaterialContactEquation );

			restartAnimation();


			camera.position.copy( rrTrackLayout[ 1 ].location );
			camera.position.z += 50;


			// document.addEventListener( "keydown", checkKeyDown );
			window.addEventListener( "resize", onWindowResize, false );
			window.addEventListener( "orientationchange", onWindowResize, false );

			stats = new Stats();
			stats.domElement.style.position = "absolute";
			stats.domElement.style.top = "0px";
			stats.domElement.style.right = "20%";
			document.body.appendChild( stats.domElement );

			setCameraPositioningMode( "Arrows" );
			// setCameraPositioningMode( "Follow" );
			// setCameraPositioningMode( "Robot" );
			// setCameraPositioningMode( "Orbit" );
			// setCameraPositioningMode( "Track" );
			animationPaused = false;

			animate();
		}

		function moveMeshToBody() {
			robotMesh.position.copy( robotBody.position );
		}

		function buttonPoller() {
			if( upDownLeftRightButton.buttonDown ) {
				var leftRightDistance = ( upDownLeftRightButton.touchPointX - 50.0 ) * upDownLeftRightButtonMaxLeftRightChange;
				if( leftRightDistance > 0 )
					moveCameraRight( leftRightDistance );
				if( leftRightDistance < 0 )
					moveCameraLeft( -leftRightDistance );
				var upDownDistance = ( upDownLeftRightButton.touchPointY - 50.0 ) * upDownLeftRightButtonMaxUpDownChange;
				if( upDownDistance > 0 )
					moveCameraDown( upDownDistance );
				if( upDownDistance < 0 )
					moveCameraUp( -upDownDistance );
			}
			if( inOutButton.buttonDown ) {
				var inOutDistance = ( inOutButton.touchPointY - 50.0 ) * inOutButtonMaxInOutChange;
				if( inOutDistance > 0 )
					moveCameraOut( inOutDistance );
				if( inOutDistance < 0 )
					moveCameraIn( -inOutDistance );
			}
		}

		function setCameraPositioningMode( mode ) {
			// disable current camera positioning mode
			switch( cameraPositioningMode ) {
				case "Arrows":
					break;
				case "Follow":
					break;
				case "Robot":
					break;
				case "Orbit":
					orbitControls.enabled = false;
					break;
				case "Track":
					break;
				default:
					break;
			}
			cameraPositioningMode = mode;
			// enable new camera positioning mode
			var titleStart = "Point of view is set to "
			switch( cameraPositioningMode ) {
				case "Arrows":
					pointOfViewTitleDiv.innerHTML = titleStart + "<span style='color:" + panelTitlePresentColor + "'>Arrows</span>";
					break;
				case "Follow":
					pointOfViewTitleDiv.innerHTML = titleStart + "<span style='color:" + panelTitlePresentColor + "'>Follow</span>";
					// Initialize the tether length between robot and camera to its present value.
					cameraTetherLength = robotMesh.position.clone().sub( camera.position ).length();
					// Initialize the manual adjustment vector to "none yet"
					cameraFollowDisplacement.set( 0, 0, 0 );
					break;
				case "Orbit":
					pointOfViewTitleDiv.innerHTML = titleStart + "<span style='color:" + panelTitlePresentColor + "'>Orbit</span>";
					orbitControls.enabled = true;
					break;
				case "Robot":
					pointOfViewTitleDiv.innerHTML = titleStart + "<span style='color:" + panelTitlePresentColor + "'>Robot</span>";
					cameraForwardViewDistance = robotMesh.position.clone().sub( camera.position ).length();
					// Initialize the manual adjustment vector to "none yet"
					cameraRobotDisplacement.set( 0, 0, 0 );
					break;
				case "Track":
					pointOfViewTitleDiv.innerHTML = titleStart + "<span style='color:" + panelTitlePresentColor + "'>Track</span>";
					break;
				default:
					break;
			}
		}

		function moveCameraUp( distance ) {
			switch( cameraPositioningMode ) {
				case "Arrows":
					// camera.position.y *= 1.1;
					camera.position.y += distance;
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					// cameraFollowDisplacement.y += 0.1 * cameraTetherLength;
					cameraFollowDisplacement.y += distance;
					break;
				case "Orbit":
					break;
				case "Robot":
					// cameraRobotDisplacement.y += 0.1 * cameraForwardViewDistance;
					cameraRobotDisplacement.y += distance;
					break;
				case "Track":
					// camera.position.y *= 1.1;
					camera.position.y += distance;
					break;
				default:
					break;
			}
		}
		function moveCameraDown( distance ) {
			switch( cameraPositioningMode ) {
				case "Arrows":
					// camera.position.y *= 0.9;
					camera.position.y -= distance;
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					// cameraFollowDisplacement.y -= 0.1 * cameraTetherLength;
					cameraFollowDisplacement.y -= distance;
					break;
				case "Orbit":
					break;
				case "Robot":
					// cameraRobotDisplacement.y -= 0.1 * cameraForwardViewDistance;
					cameraRobotDisplacement.y -= distance;
					break;
				case "Track":
					// camera.position.y *= 0.9;
					camera.position.y -= distance;
					break;
				default:
					break;
			}
		}
		function moveCameraLeft( distance ) {
			switch( cameraPositioningMode ) {
				case "Arrows":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					// camera.position.add( leftDirection.multiplyScalar( 0.1 * camera.position.length() ) );
					camera.position.add( leftDirection.multiplyScalar( distance ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					// camera.position.add( leftDirection.multiplyScalar( 0.1 * camera.position.length() ) );
					camera.position.add( leftDirection.multiplyScalar( distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Robot":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					cameraRobotDisplacement.add( leftDirection.multiplyScalar( distance ) );
					break;
				case "Track":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					// camera.position.add( leftDirection.multiplyScalar( 0.1 * camera.position.length() ) );
					camera.position.add( leftDirection.multiplyScalar( distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraRight( distance ) {
			switch( cameraPositioningMode ) {
				case "Arrows":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					// camera.position.add( leftDirection.multiplyScalar( -0.1 * camera.position.length() ) );
					camera.position.add( leftDirection.multiplyScalar( -distance ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					// camera.position.add( leftDirection.multiplyScalar( -0.1 * camera.position.length() ) );
					camera.position.add( leftDirection.multiplyScalar( -distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Robot":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					cameraRobotDisplacement.add( leftDirection.multiplyScalar( distance ) );
					break;
				case "Track":
					var leftDirection = new THREE.Vector3();
					leftDirection.crossVectors( camera.up, camera.getWorldDirection() );
					// camera.position.add( leftDirection.multiplyScalar( -0.1 * camera.position.length() ) );
					camera.position.add( leftDirection.multiplyScalar( -distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraIn( distance ) {
			switch( cameraPositioningMode ) {
				case "Arrows":
					// camera.position.add( camera.getWorldDirection().multiplyScalar( 0.1 * camera.position.length() ) );
					camera.position.add( camera.getWorldDirection().multiplyScalar( distance ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					// camera.position.add( camera.getWorldDirection().multiplyScalar( 0.1 * camera.position.length() ) );
					camera.position.add( camera.getWorldDirection().multiplyScalar( distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Robot":
					cameraRobotDisplacement.add( camera.getWorldDirection().multiplyScalar( distance ) );
					break;
				case "Track":
					// camera.position.add( camera.getWorldDirection().multiplyScalar( 0.1 * camera.position.length() ) );
					camera.position.add( camera.getWorldDirection().multiplyScalar( distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}
		function moveCameraOut( distance ) {
			switch( cameraPositioningMode ) {
				case "Arrows":
					// camera.position.add( camera.getWorldDirection().multiplyScalar( -0.1 * camera.position.length() ) );
					camera.position.add( camera.getWorldDirection().multiplyScalar( -distance ) );
					camera.updateProjectionMatrix();
					break;
				case "Follow":
					// camera.position.add( camera.getWorldDirection().multiplyScalar( -0.1 * camera.position.length() ) );
					camera.position.add( camera.getWorldDirection().multiplyScalar( -distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				case "Orbit":
					break;
				case "Robot":
					cameraRobotDisplacement.add( camera.getWorldDirection().multiplyScalar( -distance ) );
					break;
				case "Track":
					// camera.position.add( camera.getWorldDirection().multiplyScalar( -0.1 * camera.position.length() ) );
					camera.position.add( camera.getWorldDirection().multiplyScalar( -distance ) );
					camera.lookAt( robotMesh.position );
					camera.updateProjectionMatrix();
					break;
				default:
					break;
			}
		}

		function onPointOfViewButtonClick( event ) {
			if( shovelPanelIsOpen ) return;
			pointOfViewPanelDiv.style.display = "block";
			pointOfViewTitleDiv.style.display = "block";
			pointOfViewSelectArrowsDiv.style.display = "block";
			pointOfViewSelectFollowDiv.style.display = "block";
			pointOfViewSelectOrbitDiv.style.display = "block";
			pointOfViewSelectRobotDiv.style.display = "block";
			pointOfViewSelectTrackDiv.style.display = "block";
			pointOfViewClosePanelButton.style.display = "block";
			pointOfViewButton.deactivate();
			shovelButton.deactivate();
			pointOfViewPanelIsOpen = true;
			animationPaused = true;
		}
		function onPointOfViewClosePanelClick( event ) {
			pointOfViewPanelDiv.style.display = "none";
			pointOfViewTitleDiv.style.display = "none";
			pointOfViewSelectArrowsDiv.style.display = "none";
			pointOfViewSelectFollowDiv.style.display = "none";
			pointOfViewSelectOrbitDiv.style.display = "none";
			pointOfViewSelectRobotDiv.style.display = "none";
			pointOfViewSelectTrackDiv.style.display = "none";
			pointOfViewClosePanelButton.style.display = "none";
			pointOfViewButton.activate();
			shovelButton.activate();
			pointOfViewPanelIsOpen = false;
			animationPaused = false;
		}
		function onPointOfViewSelectArrowsClick( event ) {
			setCameraPositioningMode( "Arrows" );
		}
		function onPointOfViewSelectFollowClick( event ) {
			setCameraPositioningMode( "Follow" );
		}
		function onPointOfViewSelectOrbitClick( event ) {
			setCameraPositioningMode( "Orbit" );
		}
		function onPointOfViewSelectRobotClick( event ) {
			setCameraPositioningMode( "Robot" );
		}
		function onPointOfViewSelectTrackClick( event ) {
			setCameraPositioningMode( "Track" );
		}

		function onShovelButtonClick( event ) {
			if( pointOfViewPanelIsOpen ) return;
			shovelPanelDiv.style.display = "block";
			shovelToggleCannonDiv.style.display = "block";
			shovelToggleAxesDiv.style.display = "block";
			shovelToggleVisibleTrackPathPointsDiv.style.display = "block";
			shovelClosePanelButton.style.display = "block";
			shovelButton.deactivate();
			pointOfViewButton.deactivate();
			shovelPanelIsOpen = true;
			animationPaused = true;
		}
		function onShovelClosePanelClick( event ) {
			shovelPanelDiv.style.display = "none";
			shovelToggleCannonDiv.style.display = "none";
			shovelToggleAxesDiv.style.display = "none";
			shovelToggleVisibleTrackPathPointsDiv.style.display = "none";
			shovelClosePanelButton.style.display = "none";
			shovelButton.activate();
			pointOfViewButton.activate();
			shovelPanelIsOpen = false;
			animationPaused = false;
		}
		function onShovelToggleCannonClick( event ) {
			outlineBodies = !outlineBodies;
		}
		function onShovelToggleVisibleTrackPathPointsClick( event ) {
			if( trackPathPointsAreVisible ) {
				turnOffAllVisiblePoints();
			} else {
				turnOnAllVisiblePoints();
			}
		}
		function onShovelToggleAxesClick( event ) {
			if( visibleAxesVisible ) {
				visibleAxesVisible = false;
				scene.remove( visibleAxes );
			} else {
				visibleAxesVisible = true;
				scene.add( visibleAxes );
			}
			if( cannonAxesVisible ) {
				cannonAxesVisible = false;
				scene.remove( cannonAxes );
			} else {
				cannonAxesVisible = true;
				scene.add( cannonAxes );
			}
		}

		function upDownLeftRightButtonHandler( event ) {
		}

		function inOutButtonHandler( event ) {
		}

		function onCchooseTrack0ButtonClick( event ) {
			selectTrackLayout( 0 );
			turnOffAllVisiblePoints();
			makeTrackPointsFromTrackPieces();
			turnOffAllVisiblePoints();
			restartAnimation();
		}

		function onCchooseTrack1ButtonClick( event ) {
			selectTrackLayout( 1 );
			turnOffAllVisiblePoints();
			makeTrackPointsFromTrackPieces();
			turnOffAllVisiblePoints();
			restartAnimation();
		}

		function onCchooseTrack2ButtonClick( event ) {
			selectTrackLayout( 2 );
			turnOffAllVisiblePoints();
			makeTrackPointsFromTrackPieces();
			turnOffAllVisiblePoints();
			restartAnimation();
		}

		function onCchooseTrack3ButtonClick( event ) {
			selectTrackLayout( 3 );
			turnOffAllVisiblePoints();
			makeTrackPointsFromTrackPieces();
			turnOffAllVisiblePoints();
			restartAnimation();
		}

		function pointOnRobotVelocityVector( distanceFromRobot ) {
			// Get the direction of the robot's present velocity
			var robotVelocityVector = new THREE.Vector3();
			robotVelocityVector.copy( robotBody.velocity );
			// Normalize it to a length of 1
			var velocityDirectionOnlyVector = new THREE.Vector3();
			velocityDirectionOnlyVector.copy( robotVelocityVector.clone().normalize() );
			// Scale it to have a length of the desired distance from the robot
			var desiredVectorToReturn = new THREE.Vector3();
			desiredVectorToReturn.copy( velocityDirectionOnlyVector );
			desiredVectorToReturn.multiplyScalar( distanceFromRobot );
			return desiredVectorToReturn;
		}

		function onWindowResize() {
			var layout = "portrait";
			if( window.innerWidth > window.innerHeight )
				layout = "landscape";
		}

		function restartAnimation() {
			// robotBody.velocity = new CANNON.Vec3( 2000, 0, 0 );
			// robotBody.position.set( 0, 100, trackInnerRadius + ( trackWidth / 2 ) );
			robotBody.position.copy( trackPathPoints[ 0 ].location );
			robotBody.position.y += rrTrackLayout[ 0 ].trackWidth / 3;
			currentTrackPathPoint = 0;
		}

		function processPhysics() {
			currentTrackPathPointBody.position.copy( trackPathPoints[ currentTrackPathPoint ].location );
			world.step( timeStep );
			moveMeshToBody();
		}

		function render() {
			renderer.setSize( window.innerWidth, window.innerHeight );
			camera.updateProjectionMatrix();
			visibleCameraVector.update( cameraLookingAtVector );
			renderer.render( scene, camera );
		}

		function animate() {
			requestAnimationFrame( animate );
			stats.update();
			if( !pointOfViewButtonLoaded ) {
				if( pointOfViewButton != undefined ) {
					pointOfViewButtonLoaded = true;
					pointOfViewButton.activate();
				}
			}
			if( !shovelButtonLoaded ) {
				if( shovelButton != undefined ) {
					shovelButtonLoaded = true;
					shovelButton.activate();
				}
			}
			if( !restartAnimationButtonLoaded ) {
				if( restartAnimationButton != undefined ) {
					restartAnimationButtonLoaded = true;
					restartAnimationButton.activate();
				}
			}
			if( !upDownLeftRightButtonLoaded ) {
				if( upDownLeftRightButton != undefined ) {
					upDownLeftRightButtonLoaded = true;
					upDownLeftRightButton.activate();
				}
			}
			if( !inOutButtonLoaded ) {
				if( inOutButton != undefined ) {
					inOutButtonLoaded = true;
					inOutButton.activate();
				}
			}
			if( animationPaused ) return;
			var timeToAnimate;
			frameCount++;
			if( slowMotion ) {
				timeToAnimate = ( 0 ==  ( frameCount % 25 ) );
			} else {
				timeToAnimate = true;
			}
			if( ( frameCount % 3 ) == 0 ) {
				if( trackPathPointsAreVisible ) {
					// If the track path points are all visible, turn off the current one to make it noticable
					turnOnVisibleTrackPathPoint( currentTrackPathPoint );
					currentTrackPathPoint++;
					if( currentTrackPathPoint >= trackPathPoints.length ) { currentTrackPathPoint = 0; }
					turnOffVisibleTrackPathPoint( currentTrackPathPoint );
				} else {
					// If the track path points are all NOT visible, turn on the current one to make it noticable
					turnOffVisibleTrackPathPoint( currentTrackPathPoint );
					currentTrackPathPoint++;
					if( currentTrackPathPoint >= trackPathPoints.length ) { currentTrackPathPoint = 0; }
					turnOnVisibleTrackPathPoint( currentTrackPathPoint );
				}
			}
			if( timeToAnimate ) {
				buttonPoller();
				processPhysics();
				switch( cameraPositioningMode ) {
					case "Arrows":
						// Camera position is controlled by up/down/left/right/in/out controls.
						// Camera is always looking at ( 0, 0, 0 ).
						break;
					case "Follow":
						// Camera is tethered to the robot, being pulled along by it, and looking at the robot.
						// Up/down/left/right/in/out adjusts the camera position relative to the robot.
						// Get a vector from the robot location to a point along the robot velocity vector that's behind the robot by a tether length
						var cameraTetherPoint = new THREE.Vector3();
						cameraTetherPoint.copy( pointOnRobotVelocityVector( -cameraTetherLength ) );
						// Add the accumulated manual control camera adjustments to this vector
						var cameraMoveVector = new THREE.Vector3();
						cameraMoveVector.addVectors( cameraTetherPoint, cameraFollowDisplacement );
						// Add the robot's position this displacement vector to get the camera's new position in world coordinates 
						var newCameraPosition = new THREE.Vector3();
						newCameraPosition.addVectors( robotMesh.position, cameraMoveVector );
						// Don't let the camera go underground...
						newCameraPosition.y = Math.max( 0, newCameraPosition.y );
						// Update the camera position and "lookAt" parameter
						camera.position.copy( newCameraPosition );
						camera.lookAt( robotMesh.position );
						camera.updateProjectionMatrix();
						break;
					case "Orbit":
						// Camera position is controlled by the THREE.js OrbitControls function.
						orbitControls.update();
						break;
					case "Robot":
						// Camera position is that of the robot and it's looking at a point toward which the robot is moving
						var cameraLookAtPoint = new THREE.Vector3();
						cameraLookAtPoint.copy( pointOnRobotVelocityVector( cameraForwardViewDistance ) );
						camera.position.copy( robotMesh.position );
						camera.lookAt( cameraLookAtPoint );
						camera.updateProjectionMatrix();
						break;
					case "Track":
						// Camera position is controlled by up/down/left/right/in/out controls.
						// Camera is always looking at the robot.
						camera.lookAt( robotMesh.position );
						camera.updateProjectionMatrix();
						break;
					default:
						break;
				}
				if( outlineBodies )
					caDebugOutliner.update();
				else
					caDebugOutliner.depopulate();
				render();
			}
			if( !chooseTrackButtonsActivated ) {
				chooseTrackButtonsActivated = true;
				chooseTrack0Button.activate();
				chooseTrack1Button.activate();
				chooseTrack2Button.activate();
				chooseTrack3Button.activate();
			}
		}
	</script>
</body>
</html>
